// This file is generated by tools/gen_mathv.lua

#include "amulet.h"
#include "am_mathv_helper.inc"

static int add_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.add", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = ADD_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = ADD_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = ADD_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = ADD_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = ADD_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = ADD_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = ADD_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = ADD_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.add");
}

int am_mathv_add(lua_State *L) {
    return add_impl(L, NULL);
}

static int am_mathv_add_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return add_impl(L, view);
}

static int sub_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.sub", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = SUB_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = SUB_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = SUB_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = SUB_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = SUB_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = SUB_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = SUB_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = SUB_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.sub");
}

int am_mathv_sub(lua_State *L) {
    return sub_impl(L, NULL);
}

static int am_mathv_sub_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return sub_impl(L, view);
}

static int vec_mul_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.vec_mul", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = MUL_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = MUL_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = MUL_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = MUL_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = MUL_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = MUL_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = MUL_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = MUL_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec_mul");
}

static int am_mathv_vec_mul(lua_State *L) {
    return vec_mul_impl(L, NULL);
}

static int am_mathv_vec_mul_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec_mul_impl(L, view);
}

static int div_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.div", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = DIV_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = DIV_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = DIV_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = DIV_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = DIV_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = DIV_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = DIV_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = DIV_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.div");
}

int am_mathv_div(lua_State *L) {
    return div_impl(L, NULL);
}

static int am_mathv_div_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return div_impl(L, view);
}

static int mod_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.mod", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = F32MOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = F32MOD_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = F64MOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = F64MOD_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = IMOD_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = IMOD_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = IMOD_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = IMOD_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = IMOD_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = IMOD_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mod");
}

int am_mathv_mod(lua_State *L) {
    return mod_impl(L, NULL);
}

static int am_mathv_mod_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mod_impl(L, view);
}

static int pow_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.pow", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = powf(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = powf(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = pow(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = pow(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.pow");
}

int am_mathv_pow(lua_State *L) {
    return pow_impl(L, NULL);
}

static int am_mathv_pow_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return pow_impl(L, view);
}

static int unm_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.unm", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = UNM_OP(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = UNM_OP(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_I8) {
        if (is_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = UNM_OP(((int8_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_U8) {
        if (is_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = UNM_OP(((uint8_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_I16) {
        if (is_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = UNM_OP(((int16_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_U16) {
        if (is_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = UNM_OP(((uint16_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_I32) {
        if (is_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = UNM_OP(((int32_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_U32) {
        if (is_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = UNM_OP(((uint32_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.unm");
}

int am_mathv_unm(lua_State *L) {
    return unm_impl(L, NULL);
}

static int am_mathv_unm_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return unm_impl(L, view);
}

static int abs_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.abs", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = fabsf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = fabsf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = fabs(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = fabs(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.abs");
}

static int am_mathv_abs(lua_State *L) {
    return abs_impl(L, NULL);
}

static int am_mathv_abs_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return abs_impl(L, view);
}

static int acos_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.acos", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = acosf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = acosf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = acos(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = acos(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.acos");
}

static int am_mathv_acos(lua_State *L) {
    return acos_impl(L, NULL);
}

static int am_mathv_acos_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return acos_impl(L, view);
}

static int asin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.asin", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = asinf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = asinf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = asin(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = asin(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.asin");
}

static int am_mathv_asin(lua_State *L) {
    return asin_impl(L, NULL);
}

static int am_mathv_asin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return asin_impl(L, view);
}

static int atan_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.atan", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = atanf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = atanf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = atan(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = atan(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.atan");
}

static int am_mathv_atan(lua_State *L) {
    return atan_impl(L, NULL);
}

static int am_mathv_atan_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return atan_impl(L, view);
}

static int atan2_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.atan2", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = atan2f(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = atan2f(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = atan2(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = atan2(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.atan2");
}

static int am_mathv_atan2(lua_State *L) {
    return atan2_impl(L, NULL);
}

static int am_mathv_atan2_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return atan2_impl(L, view);
}

static int ceil_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.ceil", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ceilf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = ceilf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = ceil(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = ceil(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.ceil");
}

static int am_mathv_ceil(lua_State *L) {
    return ceil_impl(L, NULL);
}

static int am_mathv_ceil_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return ceil_impl(L, view);
}

static int cos_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.cos", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = cosf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = cosf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = cos(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = cos(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.cos");
}

static int am_mathv_cos(lua_State *L) {
    return cos_impl(L, NULL);
}

static int am_mathv_cos_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return cos_impl(L, view);
}

static int floor_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.floor", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = floorf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = floorf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = floor(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = floor(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.floor");
}

static int am_mathv_floor(lua_State *L) {
    return floor_impl(L, NULL);
}

static int am_mathv_floor_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return floor_impl(L, view);
}

static int log_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.log", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = logf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = logf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = log(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = log(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.log");
}

static int am_mathv_log(lua_State *L) {
    return log_impl(L, NULL);
}

static int am_mathv_log_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return log_impl(L, view);
}

static int max_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.max", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = am_max(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_max(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = am_max(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_max(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.max");
}

static int am_mathv_max(lua_State *L) {
    return max_impl(L, NULL);
}

static int am_mathv_max_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return max_impl(L, view);
}

static int min_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.min", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = am_min(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_min(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = am_min(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_min(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.min");
}

static int am_mathv_min(lua_State *L) {
    return min_impl(L, NULL);
}

static int am_mathv_min_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return min_impl(L, view);
}

static int sin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.sin", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = sinf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = sinf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = sin(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = sin(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.sin");
}

static int am_mathv_sin(lua_State *L) {
    return sin_impl(L, NULL);
}

static int am_mathv_sin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return sin_impl(L, view);
}

static int tan_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (int i = 0; i < nargs; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    am_buffer_view_type output_view_type;
    int output_count;
    int output_components;
    int output_stride;
    uint8_t *output_data;
    bool is_dense;
    component_wise_setup(L, target, "mathv.tan", nargs, arg_data,
        arg_stride, arg_components, arg_singleton_bufs, 
        &output_view_type, &output_count, &output_components, &output_stride, &output_data, &is_dense);
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F32) {
        if (is_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = tanf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = tanf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1 && output_view_type == AM_VIEW_TYPE_F64) {
        if (is_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            for (int i = 0; i < output_count * output_components; ++i) {
                out_arr[i] = tan(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (int i = 0; i < output_count; ++i) {
                for (int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = tan(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.tan");
}

static int am_mathv_tan(lua_State *L) {
    return tan_impl(L, NULL);
}

static int am_mathv_tan_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return tan_impl(L, view);
}

static int vec2_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.vec2");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.vec2");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.vec2");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.vec2 argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 2;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec2*)output_ptr) = glm::vec2(*((float*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 2;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec2*)output_ptr) = glm::vec2(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 2;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec2*)output_ptr) = glm::dvec2(*((double*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 2;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec2*)output_ptr) = glm::dvec2(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec2");
}

static int am_mathv_vec2(lua_State *L) {
    return vec2_impl(L, NULL);
}

static int am_mathv_vec2_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec2_impl(L, view);
}

static int vec3_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 3) return luaL_error(L, "too many arguments for mathv.vec3");
    double arg_singleton_vals[3][16];
    int arg_count[3];
    uint8_t *arg_data[3];
    int arg_stride[3];
    int arg_components[3];
    int arg_type[3];
    am_buffer_view_type arg_view_type[3];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.vec3");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.vec3");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.vec3 argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = glm::vec3(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = glm::vec3(*((glm::vec2*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = glm::vec3(*((float*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = glm::vec3(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = glm::dvec3(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = glm::dvec3(*((glm::dvec2*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = glm::dvec3(*((double*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = glm::dvec3(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec3");
}

static int am_mathv_vec3(lua_State *L) {
    return vec3_impl(L, NULL);
}

static int am_mathv_vec3_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec3_impl(L, view);
}

static int vec4_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 4) return luaL_error(L, "too many arguments for mathv.vec4");
    double arg_singleton_vals[4][16];
    int arg_count[4];
    uint8_t *arg_data[4];
    int arg_stride[4];
    int arg_components[4];
    int arg_type[4];
    am_buffer_view_type arg_view_type[4];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.vec4");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.vec4");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.vec4 argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 4  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[3]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[3] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((glm::vec3*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((float*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 2 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((glm::vec2*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((float*)in_ptr_1), *((glm::vec2*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((glm::vec2*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = glm::vec4(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            arg_data[3] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((glm::dvec3*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((double*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 2 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((glm::dvec2*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((double*)in_ptr_1), *((glm::dvec2*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((glm::dvec2*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = glm::dvec4(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec4");
}

static int am_mathv_vec4(lua_State *L) {
    return vec4_impl(L, NULL);
}

static int am_mathv_vec4_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec4_impl(L, view);
}

static int mat3_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 9) return luaL_error(L, "too many arguments for mathv.mat3");
    double arg_singleton_vals[9][16];
    int arg_count[9];
    uint8_t *arg_data[9];
    int arg_stride[9];
    int arg_components[9];
    int arg_type[9];
    am_buffer_view_type arg_view_type[9];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.mat3");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.mat3");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.mat3 argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 9  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F32) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F32) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F32) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F32) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F32) || arg_type[8] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[3]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[3] = (uint8_t*)f64s;
        }
        if (arg_type[4] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[4][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[4]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[4] = (uint8_t*)f64s;
        }
        if (arg_type[5] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[5][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[5]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[5] = (uint8_t*)f64s;
        }
        if (arg_type[6] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[6][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[6]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[6] = (uint8_t*)f64s;
        }
        if (arg_type[7] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[7][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[7]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[7] = (uint8_t*)f64s;
        }
        if (arg_type[8] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[8][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[8]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[8] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat3*)output_ptr) = glm::mat3(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4), *((float*)in_ptr_5), *((float*)in_ptr_6), *((float*)in_ptr_7), *((float*)in_ptr_8), *((float*)in_ptr_9));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 3 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat3*)output_ptr) = glm::mat3(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2), *((glm::vec3*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 9  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F64) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F64) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F64) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F64) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F64) || arg_type[8] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            arg_data[3] = (uint8_t*)f64s;
        }
        if (arg_type[4] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[4][0];
            arg_data[4] = (uint8_t*)f64s;
        }
        if (arg_type[5] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[5][0];
            arg_data[5] = (uint8_t*)f64s;
        }
        if (arg_type[6] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[6][0];
            arg_data[6] = (uint8_t*)f64s;
        }
        if (arg_type[7] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[7][0];
            arg_data[7] = (uint8_t*)f64s;
        }
        if (arg_type[8] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[8][0];
            arg_data[8] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat3*)output_ptr) = glm::dmat3(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4), *((double*)in_ptr_5), *((double*)in_ptr_6), *((double*)in_ptr_7), *((double*)in_ptr_8), *((double*)in_ptr_9));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 3 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat3*)output_ptr) = glm::dmat3(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2), *((glm::dvec3*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat3");
}

static int am_mathv_mat3(lua_State *L) {
    return mat3_impl(L, NULL);
}

static int am_mathv_mat3_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat3_impl(L, view);
}

static int mat4_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 16) return luaL_error(L, "too many arguments for mathv.mat4");
    double arg_singleton_vals[16][16];
    int arg_count[16];
    uint8_t *arg_data[16];
    int arg_stride[16];
    int arg_components[16];
    int arg_type[16];
    am_buffer_view_type arg_view_type[16];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.mat4");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.mat4");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.mat4 argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 16  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F32) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F32) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F32) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F32) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F32) || arg_type[8] != MT_am_buffer_view) && arg_components[9] == 1 && ((arg_type[9] == MT_am_buffer_view && arg_view_type[9] == AM_VIEW_TYPE_F32) || arg_type[9] != MT_am_buffer_view) && arg_components[10] == 1 && ((arg_type[10] == MT_am_buffer_view && arg_view_type[10] == AM_VIEW_TYPE_F32) || arg_type[10] != MT_am_buffer_view) && arg_components[11] == 1 && ((arg_type[11] == MT_am_buffer_view && arg_view_type[11] == AM_VIEW_TYPE_F32) || arg_type[11] != MT_am_buffer_view) && arg_components[12] == 1 && ((arg_type[12] == MT_am_buffer_view && arg_view_type[12] == AM_VIEW_TYPE_F32) || arg_type[12] != MT_am_buffer_view) && arg_components[13] == 1 && ((arg_type[13] == MT_am_buffer_view && arg_view_type[13] == AM_VIEW_TYPE_F32) || arg_type[13] != MT_am_buffer_view) && arg_components[14] == 1 && ((arg_type[14] == MT_am_buffer_view && arg_view_type[14] == AM_VIEW_TYPE_F32) || arg_type[14] != MT_am_buffer_view) && arg_components[15] == 1 && ((arg_type[15] == MT_am_buffer_view && arg_view_type[15] == AM_VIEW_TYPE_F32) || arg_type[15] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[3]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[3] = (uint8_t*)f64s;
        }
        if (arg_type[4] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[4][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[4]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[4] = (uint8_t*)f64s;
        }
        if (arg_type[5] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[5][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[5]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[5] = (uint8_t*)f64s;
        }
        if (arg_type[6] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[6][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[6]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[6] = (uint8_t*)f64s;
        }
        if (arg_type[7] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[7][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[7]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[7] = (uint8_t*)f64s;
        }
        if (arg_type[8] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[8][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[8]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[8] = (uint8_t*)f64s;
        }
        if (arg_type[9] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[9][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[9]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[9] = (uint8_t*)f64s;
        }
        if (arg_type[10] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[10][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[10]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[10] = (uint8_t*)f64s;
        }
        if (arg_type[11] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[11][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[11]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[11] = (uint8_t*)f64s;
        }
        if (arg_type[12] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[12][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[12]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[12] = (uint8_t*)f64s;
        }
        if (arg_type[13] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[13][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[13]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[13] = (uint8_t*)f64s;
        }
        if (arg_type[14] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[14][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[14]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[14] = (uint8_t*)f64s;
        }
        if (arg_type[15] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[15][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[15]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[15] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        int in_stride_10 = arg_stride[9];
        uint8_t *in_ptr_10 = &arg_data[9][0];
        int in_stride_11 = arg_stride[10];
        uint8_t *in_ptr_11 = &arg_data[10][0];
        int in_stride_12 = arg_stride[11];
        uint8_t *in_ptr_12 = &arg_data[11][0];
        int in_stride_13 = arg_stride[12];
        uint8_t *in_ptr_13 = &arg_data[12][0];
        int in_stride_14 = arg_stride[13];
        uint8_t *in_ptr_14 = &arg_data[13][0];
        int in_stride_15 = arg_stride[14];
        uint8_t *in_ptr_15 = &arg_data[14][0];
        int in_stride_16 = arg_stride[15];
        uint8_t *in_ptr_16 = &arg_data[15][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat4*)output_ptr) = glm::mat4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4), *((float*)in_ptr_5), *((float*)in_ptr_6), *((float*)in_ptr_7), *((float*)in_ptr_8), *((float*)in_ptr_9), *((float*)in_ptr_10), *((float*)in_ptr_11), *((float*)in_ptr_12), *((float*)in_ptr_13), *((float*)in_ptr_14), *((float*)in_ptr_15), *((float*)in_ptr_16));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            in_ptr_10 += in_stride_10;
            in_ptr_11 += in_stride_11;
            in_ptr_12 += in_stride_12;
            in_ptr_13 += in_stride_13;
            in_ptr_14 += in_stride_14;
            in_ptr_15 += in_stride_15;
            in_ptr_16 += in_stride_16;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 4 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 4 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[2]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[3]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[3] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat4*)output_ptr) = glm::mat4(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2), *((glm::vec4*)in_ptr_3), *((glm::vec4*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 16  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F64) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F64) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F64) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F64) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F64) || arg_type[8] != MT_am_buffer_view) && arg_components[9] == 1 && ((arg_type[9] == MT_am_buffer_view && arg_view_type[9] == AM_VIEW_TYPE_F64) || arg_type[9] != MT_am_buffer_view) && arg_components[10] == 1 && ((arg_type[10] == MT_am_buffer_view && arg_view_type[10] == AM_VIEW_TYPE_F64) || arg_type[10] != MT_am_buffer_view) && arg_components[11] == 1 && ((arg_type[11] == MT_am_buffer_view && arg_view_type[11] == AM_VIEW_TYPE_F64) || arg_type[11] != MT_am_buffer_view) && arg_components[12] == 1 && ((arg_type[12] == MT_am_buffer_view && arg_view_type[12] == AM_VIEW_TYPE_F64) || arg_type[12] != MT_am_buffer_view) && arg_components[13] == 1 && ((arg_type[13] == MT_am_buffer_view && arg_view_type[13] == AM_VIEW_TYPE_F64) || arg_type[13] != MT_am_buffer_view) && arg_components[14] == 1 && ((arg_type[14] == MT_am_buffer_view && arg_view_type[14] == AM_VIEW_TYPE_F64) || arg_type[14] != MT_am_buffer_view) && arg_components[15] == 1 && ((arg_type[15] == MT_am_buffer_view && arg_view_type[15] == AM_VIEW_TYPE_F64) || arg_type[15] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            arg_data[3] = (uint8_t*)f64s;
        }
        if (arg_type[4] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[4][0];
            arg_data[4] = (uint8_t*)f64s;
        }
        if (arg_type[5] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[5][0];
            arg_data[5] = (uint8_t*)f64s;
        }
        if (arg_type[6] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[6][0];
            arg_data[6] = (uint8_t*)f64s;
        }
        if (arg_type[7] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[7][0];
            arg_data[7] = (uint8_t*)f64s;
        }
        if (arg_type[8] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[8][0];
            arg_data[8] = (uint8_t*)f64s;
        }
        if (arg_type[9] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[9][0];
            arg_data[9] = (uint8_t*)f64s;
        }
        if (arg_type[10] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[10][0];
            arg_data[10] = (uint8_t*)f64s;
        }
        if (arg_type[11] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[11][0];
            arg_data[11] = (uint8_t*)f64s;
        }
        if (arg_type[12] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[12][0];
            arg_data[12] = (uint8_t*)f64s;
        }
        if (arg_type[13] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[13][0];
            arg_data[13] = (uint8_t*)f64s;
        }
        if (arg_type[14] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[14][0];
            arg_data[14] = (uint8_t*)f64s;
        }
        if (arg_type[15] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[15][0];
            arg_data[15] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        int in_stride_10 = arg_stride[9];
        uint8_t *in_ptr_10 = &arg_data[9][0];
        int in_stride_11 = arg_stride[10];
        uint8_t *in_ptr_11 = &arg_data[10][0];
        int in_stride_12 = arg_stride[11];
        uint8_t *in_ptr_12 = &arg_data[11][0];
        int in_stride_13 = arg_stride[12];
        uint8_t *in_ptr_13 = &arg_data[12][0];
        int in_stride_14 = arg_stride[13];
        uint8_t *in_ptr_14 = &arg_data[13][0];
        int in_stride_15 = arg_stride[14];
        uint8_t *in_ptr_15 = &arg_data[14][0];
        int in_stride_16 = arg_stride[15];
        uint8_t *in_ptr_16 = &arg_data[15][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat4*)output_ptr) = glm::dmat4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4), *((double*)in_ptr_5), *((double*)in_ptr_6), *((double*)in_ptr_7), *((double*)in_ptr_8), *((double*)in_ptr_9), *((double*)in_ptr_10), *((double*)in_ptr_11), *((double*)in_ptr_12), *((double*)in_ptr_13), *((double*)in_ptr_14), *((double*)in_ptr_15), *((double*)in_ptr_16));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            in_ptr_10 += in_stride_10;
            in_ptr_11 += in_stride_11;
            in_ptr_12 += in_stride_12;
            in_ptr_13 += in_stride_13;
            in_ptr_14 += in_stride_14;
            in_ptr_15 += in_stride_15;
            in_ptr_16 += in_stride_16;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 4 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 4 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        if (arg_type[2] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[2][0];
            arg_data[2] = (uint8_t*)f64s;
        }
        if (arg_type[3] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[3][0];
            arg_data[3] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat4*)output_ptr) = glm::dmat4(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2), *((glm::dvec4*)in_ptr_3), *((glm::dvec4*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat4");
}

static int am_mathv_mat4(lua_State *L) {
    return mat4_impl(L, NULL);
}

static int am_mathv_mat4_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat4_impl(L, view);
}

static int mat_mul_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.mat_mul");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.mat_mul");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.mat_mul");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.mat_mul argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat4*)output_ptr) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec4*)output_ptr) = MAT_MUL(*((glm::vec4*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat4*)output_ptr) = MAT_MUL(*((float*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat4*)output_ptr) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat3*)output_ptr) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::vec3*)output_ptr) = MAT_MUL(*((glm::vec3*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat3*)output_ptr) = MAT_MUL(*((float*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::mat3*)output_ptr) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat4*)output_ptr) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 4;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec4*)output_ptr) = MAT_MUL(*((glm::dvec4*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat4*)output_ptr) = MAT_MUL(*((double*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 16;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat4*)output_ptr) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat3*)output_ptr) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 3;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dvec3*)output_ptr) = MAT_MUL(*((glm::dvec3*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat3*)output_ptr) = MAT_MUL(*((double*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 9;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((glm::dmat3*)output_ptr) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat_mul");
}

static int am_mathv_mat_mul(lua_State *L) {
    return mat_mul_impl(L, NULL);
}

static int am_mathv_mat_mul_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat_mul_impl(L, view);
}

static int dot_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.dot");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.dot");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.dot");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.dot argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::dot(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::dot(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::dot(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.dot");
}

static int am_mathv_dot(lua_State *L) {
    return dot_impl(L, NULL);
}

static int am_mathv_dot_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return dot_impl(L, view);
}

static int perlin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.perlin");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.perlin");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.perlin");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.perlin argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = PERLIN1_F32(*((float*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = PERLIN2_F32(*((float*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::perlin(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = PERLIN1_F64(*((double*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = PERLIN2_F64(*((double*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            arg_data[1] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = glm::perlin(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.perlin");
}

static int am_mathv_perlin(lua_State *L) {
    return perlin_impl(L, NULL);
}

static int am_mathv_perlin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return perlin_impl(L, view);
}

static int simplex_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.simplex");
    double arg_singleton_vals[1][16];
    int arg_count[1];
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.simplex");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.simplex");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.simplex argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = SIMPLEX1_F32(*((float*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::simplex(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::simplex(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(float);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F32) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F32].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::simplex(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = SIMPLEX1_F64(*((double*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = SIMPLEX2_F64(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = SIMPLEX3_F64(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            arg_data[0] = (uint8_t*)f64s;
        }
        int output_components = 1;
        uint8_t *output_ptr;
        int out_stride;
        if (target == NULL) {
            // create a new buffer for the output
            out_stride = output_components * sizeof(double);
        
            am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(double));
            output_ptr = output_buffer->data;
            am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F64, output_components);
            output_view->buffer = output_buffer;
            output_view->buffer_ref = output_view->ref(L, -2);
            output_view->offset = 0;
            output_view->stride = out_stride;
            output_view->size = count;
            output_view->last_max_elem_version = 0;
            output_view->max_elem = 0;
        
            lua_remove(L, -2); // remove output_buffer
        } else {
            // overwrite provided buffer
            if (target->type != AM_VIEW_TYPE_F64) {
                return luaL_error(L, "target view has incorrect type (expecting %s, got %s)",
                    am_view_type_infos[AM_VIEW_TYPE_F64].name, am_view_type_infos[target->type].name);
            }
            if (target->components != output_components) {
                return luaL_error(L, "target view has incorrect number of components (expecting %d, got %d)",
                    output_components, target->components);
            }
            count = am_min(count, target->size);
            target->mark_dirty(0, count);
            out_stride = target->stride;
            output_ptr = target->buffer->data + target->offset;
        }
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (int i = 0; i < count; ++i) {
            *((double*)output_ptr) = SIMPLEX4_F64(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.simplex");
}

static int am_mathv_simplex(lua_State *L) {
    return simplex_impl(L, NULL);
}

static int am_mathv_simplex_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return simplex_impl(L, view);
}

void am_register_mathv_view_methods(lua_State *L) {
    lua_pushcclosure(L, am_mathv_add, 0);
    lua_setfield(L, -2, "__add");
    lua_pushcclosure(L, am_mathv_sub, 0);
    lua_setfield(L, -2, "__sub");
    lua_pushcclosure(L, am_mathv_mul, 0);
    lua_setfield(L, -2, "__mul");
    lua_pushcclosure(L, am_mathv_div, 0);
    lua_setfield(L, -2, "__div");
    lua_pushcclosure(L, am_mathv_mod, 0);
    lua_setfield(L, -2, "__mod");
    lua_pushcclosure(L, am_mathv_pow, 0);
    lua_setfield(L, -2, "__pow");
    lua_pushcclosure(L, am_mathv_unm, 0);
    lua_setfield(L, -2, "__unm");
    lua_pushcclosure(L, am_mathv_add_into, 0);
    lua_setfield(L, -2, "add");
    lua_pushcclosure(L, am_mathv_sub_into, 0);
    lua_setfield(L, -2, "sub");
    lua_pushcclosure(L, am_mathv_vec_mul_into, 0);
    lua_setfield(L, -2, "vec_mul");
    lua_pushcclosure(L, am_mathv_div_into, 0);
    lua_setfield(L, -2, "div");
    lua_pushcclosure(L, am_mathv_mod_into, 0);
    lua_setfield(L, -2, "mod");
    lua_pushcclosure(L, am_mathv_pow_into, 0);
    lua_setfield(L, -2, "pow");
    lua_pushcclosure(L, am_mathv_unm_into, 0);
    lua_setfield(L, -2, "unm");
    lua_pushcclosure(L, am_mathv_abs_into, 0);
    lua_setfield(L, -2, "abs");
    lua_pushcclosure(L, am_mathv_acos_into, 0);
    lua_setfield(L, -2, "acos");
    lua_pushcclosure(L, am_mathv_asin_into, 0);
    lua_setfield(L, -2, "asin");
    lua_pushcclosure(L, am_mathv_atan_into, 0);
    lua_setfield(L, -2, "atan");
    lua_pushcclosure(L, am_mathv_atan2_into, 0);
    lua_setfield(L, -2, "atan2");
    lua_pushcclosure(L, am_mathv_ceil_into, 0);
    lua_setfield(L, -2, "ceil");
    lua_pushcclosure(L, am_mathv_cos_into, 0);
    lua_setfield(L, -2, "cos");
    lua_pushcclosure(L, am_mathv_floor_into, 0);
    lua_setfield(L, -2, "floor");
    lua_pushcclosure(L, am_mathv_log_into, 0);
    lua_setfield(L, -2, "log");
    lua_pushcclosure(L, am_mathv_max_into, 0);
    lua_setfield(L, -2, "max");
    lua_pushcclosure(L, am_mathv_min_into, 0);
    lua_setfield(L, -2, "min");
    lua_pushcclosure(L, am_mathv_sin_into, 0);
    lua_setfield(L, -2, "sin");
    lua_pushcclosure(L, am_mathv_tan_into, 0);
    lua_setfield(L, -2, "tan");
    lua_pushcclosure(L, am_mathv_vec2_into, 0);
    lua_setfield(L, -2, "vec2");
    lua_pushcclosure(L, am_mathv_vec3_into, 0);
    lua_setfield(L, -2, "vec3");
    lua_pushcclosure(L, am_mathv_vec4_into, 0);
    lua_setfield(L, -2, "vec4");
    lua_pushcclosure(L, am_mathv_mat3_into, 0);
    lua_setfield(L, -2, "mat3");
    lua_pushcclosure(L, am_mathv_mat4_into, 0);
    lua_setfield(L, -2, "mat4");
    lua_pushcclosure(L, am_mathv_mat_mul_into, 0);
    lua_setfield(L, -2, "mat_mul");
    lua_pushcclosure(L, am_mathv_dot_into, 0);
    lua_setfield(L, -2, "dot");
    lua_pushcclosure(L, am_mathv_perlin_into, 0);
    lua_setfield(L, -2, "perlin");
    lua_pushcclosure(L, am_mathv_simplex_into, 0);
    lua_setfield(L, -2, "simplex");
}

void am_open_mathv_module(lua_State *L) {
    luaL_Reg vfuncs[] = {
        {"range",   am_mathv_range},
        {"random",  am_mathv_random},
        {"cart",    am_mathv_cart},
        {"mul",     am_mathv_mul},
        {"add", am_mathv_add},
        {"sub", am_mathv_sub},
        {"vec_mul", am_mathv_vec_mul},
        {"div", am_mathv_div},
        {"mod", am_mathv_mod},
        {"pow", am_mathv_pow},
        {"unm", am_mathv_unm},
        {"abs", am_mathv_abs},
        {"acos", am_mathv_acos},
        {"asin", am_mathv_asin},
        {"atan", am_mathv_atan},
        {"atan2", am_mathv_atan2},
        {"ceil", am_mathv_ceil},
        {"cos", am_mathv_cos},
        {"floor", am_mathv_floor},
        {"log", am_mathv_log},
        {"max", am_mathv_max},
        {"min", am_mathv_min},
        {"sin", am_mathv_sin},
        {"tan", am_mathv_tan},
        {"vec2", am_mathv_vec2},
        {"vec3", am_mathv_vec3},
        {"vec4", am_mathv_vec4},
        {"mat3", am_mathv_mat3},
        {"mat4", am_mathv_mat4},
        {"mat_mul", am_mathv_mat_mul},
        {"dot", am_mathv_dot},
        {"perlin", am_mathv_perlin},
        {"simplex", am_mathv_simplex},
        {NULL, NULL}
    };
    am_open_module(L, "mathv", vfuncs);
}
