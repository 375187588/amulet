// This file is generated by tools/gen_mathv.lua
#include "amulet.h"
#include "am_mathv_helper.inc"
int am_mathv_add(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.add");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.add.\nsupported signatures are:\n  mathv.add(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.add");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.add argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to add argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = ADD_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = ADD_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = ADD_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = ADD_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = ADD_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = ADD_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            case 9: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_5;
                if (arg_components[0] > 1) {
                    in_ptr_1_5 = &arg_data[0][0] + 4 * sizeof(float);
                } else {
                    in_ptr_1_5 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_6;
                if (arg_components[0] > 1) {
                    in_ptr_1_6 = &arg_data[0][0] + 5 * sizeof(float);
                } else {
                    in_ptr_1_6 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_7;
                if (arg_components[0] > 1) {
                    in_ptr_1_7 = &arg_data[0][0] + 6 * sizeof(float);
                } else {
                    in_ptr_1_7 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_8;
                if (arg_components[0] > 1) {
                    in_ptr_1_8 = &arg_data[0][0] + 7 * sizeof(float);
                } else {
                    in_ptr_1_8 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_9;
                if (arg_components[0] > 1) {
                    in_ptr_1_9 = &arg_data[0][0] + 8 * sizeof(float);
                } else {
                    in_ptr_1_9 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_5;
                if (arg_components[1] > 1) {
                    in_ptr_2_5 = &arg_data[1][0] + 4 * sizeof(float);
                } else {
                    in_ptr_2_5 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_6;
                if (arg_components[1] > 1) {
                    in_ptr_2_6 = &arg_data[1][0] + 5 * sizeof(float);
                } else {
                    in_ptr_2_6 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_7;
                if (arg_components[1] > 1) {
                    in_ptr_2_7 = &arg_data[1][0] + 6 * sizeof(float);
                } else {
                    in_ptr_2_7 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_8;
                if (arg_components[1] > 1) {
                    in_ptr_2_8 = &arg_data[1][0] + 7 * sizeof(float);
                } else {
                    in_ptr_2_8 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_9;
                if (arg_components[1] > 1) {
                    in_ptr_2_9 = &arg_data[1][0] + 8 * sizeof(float);
                } else {
                    in_ptr_2_9 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                uint8_t *out_ptr_5 = output_ptr + 4 * sizeof(float);
                uint8_t *out_ptr_6 = output_ptr + 5 * sizeof(float);
                uint8_t *out_ptr_7 = output_ptr + 6 * sizeof(float);
                uint8_t *out_ptr_8 = output_ptr + 7 * sizeof(float);
                uint8_t *out_ptr_9 = output_ptr + 8 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = ADD_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = ADD_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = ADD_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                    *((float*)out_ptr_5) = ADD_F32(*((float*)in_ptr_1_5), *((float*)in_ptr_2_5));
                    in_ptr_1_5 += in_stride_1;
                    in_ptr_2_5 += in_stride_2;
                    out_ptr_5 += out_stride;
                    *((float*)out_ptr_6) = ADD_F32(*((float*)in_ptr_1_6), *((float*)in_ptr_2_6));
                    in_ptr_1_6 += in_stride_1;
                    in_ptr_2_6 += in_stride_2;
                    out_ptr_6 += out_stride;
                    *((float*)out_ptr_7) = ADD_F32(*((float*)in_ptr_1_7), *((float*)in_ptr_2_7));
                    in_ptr_1_7 += in_stride_1;
                    in_ptr_2_7 += in_stride_2;
                    out_ptr_7 += out_stride;
                    *((float*)out_ptr_8) = ADD_F32(*((float*)in_ptr_1_8), *((float*)in_ptr_2_8));
                    in_ptr_1_8 += in_stride_1;
                    in_ptr_2_8 += in_stride_2;
                    out_ptr_8 += out_stride;
                    *((float*)out_ptr_9) = ADD_F32(*((float*)in_ptr_1_9), *((float*)in_ptr_2_9));
                    in_ptr_1_9 += in_stride_1;
                    in_ptr_2_9 += in_stride_2;
                    out_ptr_9 += out_stride;
                }
                return 1;
            }
            case 16: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_5;
                if (arg_components[0] > 1) {
                    in_ptr_1_5 = &arg_data[0][0] + 4 * sizeof(float);
                } else {
                    in_ptr_1_5 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_6;
                if (arg_components[0] > 1) {
                    in_ptr_1_6 = &arg_data[0][0] + 5 * sizeof(float);
                } else {
                    in_ptr_1_6 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_7;
                if (arg_components[0] > 1) {
                    in_ptr_1_7 = &arg_data[0][0] + 6 * sizeof(float);
                } else {
                    in_ptr_1_7 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_8;
                if (arg_components[0] > 1) {
                    in_ptr_1_8 = &arg_data[0][0] + 7 * sizeof(float);
                } else {
                    in_ptr_1_8 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_9;
                if (arg_components[0] > 1) {
                    in_ptr_1_9 = &arg_data[0][0] + 8 * sizeof(float);
                } else {
                    in_ptr_1_9 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_10;
                if (arg_components[0] > 1) {
                    in_ptr_1_10 = &arg_data[0][0] + 9 * sizeof(float);
                } else {
                    in_ptr_1_10 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_11;
                if (arg_components[0] > 1) {
                    in_ptr_1_11 = &arg_data[0][0] + 10 * sizeof(float);
                } else {
                    in_ptr_1_11 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_12;
                if (arg_components[0] > 1) {
                    in_ptr_1_12 = &arg_data[0][0] + 11 * sizeof(float);
                } else {
                    in_ptr_1_12 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_13;
                if (arg_components[0] > 1) {
                    in_ptr_1_13 = &arg_data[0][0] + 12 * sizeof(float);
                } else {
                    in_ptr_1_13 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_14;
                if (arg_components[0] > 1) {
                    in_ptr_1_14 = &arg_data[0][0] + 13 * sizeof(float);
                } else {
                    in_ptr_1_14 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_15;
                if (arg_components[0] > 1) {
                    in_ptr_1_15 = &arg_data[0][0] + 14 * sizeof(float);
                } else {
                    in_ptr_1_15 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_16;
                if (arg_components[0] > 1) {
                    in_ptr_1_16 = &arg_data[0][0] + 15 * sizeof(float);
                } else {
                    in_ptr_1_16 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_5;
                if (arg_components[1] > 1) {
                    in_ptr_2_5 = &arg_data[1][0] + 4 * sizeof(float);
                } else {
                    in_ptr_2_5 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_6;
                if (arg_components[1] > 1) {
                    in_ptr_2_6 = &arg_data[1][0] + 5 * sizeof(float);
                } else {
                    in_ptr_2_6 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_7;
                if (arg_components[1] > 1) {
                    in_ptr_2_7 = &arg_data[1][0] + 6 * sizeof(float);
                } else {
                    in_ptr_2_7 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_8;
                if (arg_components[1] > 1) {
                    in_ptr_2_8 = &arg_data[1][0] + 7 * sizeof(float);
                } else {
                    in_ptr_2_8 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_9;
                if (arg_components[1] > 1) {
                    in_ptr_2_9 = &arg_data[1][0] + 8 * sizeof(float);
                } else {
                    in_ptr_2_9 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_10;
                if (arg_components[1] > 1) {
                    in_ptr_2_10 = &arg_data[1][0] + 9 * sizeof(float);
                } else {
                    in_ptr_2_10 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_11;
                if (arg_components[1] > 1) {
                    in_ptr_2_11 = &arg_data[1][0] + 10 * sizeof(float);
                } else {
                    in_ptr_2_11 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_12;
                if (arg_components[1] > 1) {
                    in_ptr_2_12 = &arg_data[1][0] + 11 * sizeof(float);
                } else {
                    in_ptr_2_12 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_13;
                if (arg_components[1] > 1) {
                    in_ptr_2_13 = &arg_data[1][0] + 12 * sizeof(float);
                } else {
                    in_ptr_2_13 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_14;
                if (arg_components[1] > 1) {
                    in_ptr_2_14 = &arg_data[1][0] + 13 * sizeof(float);
                } else {
                    in_ptr_2_14 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_15;
                if (arg_components[1] > 1) {
                    in_ptr_2_15 = &arg_data[1][0] + 14 * sizeof(float);
                } else {
                    in_ptr_2_15 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_16;
                if (arg_components[1] > 1) {
                    in_ptr_2_16 = &arg_data[1][0] + 15 * sizeof(float);
                } else {
                    in_ptr_2_16 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                uint8_t *out_ptr_5 = output_ptr + 4 * sizeof(float);
                uint8_t *out_ptr_6 = output_ptr + 5 * sizeof(float);
                uint8_t *out_ptr_7 = output_ptr + 6 * sizeof(float);
                uint8_t *out_ptr_8 = output_ptr + 7 * sizeof(float);
                uint8_t *out_ptr_9 = output_ptr + 8 * sizeof(float);
                uint8_t *out_ptr_10 = output_ptr + 9 * sizeof(float);
                uint8_t *out_ptr_11 = output_ptr + 10 * sizeof(float);
                uint8_t *out_ptr_12 = output_ptr + 11 * sizeof(float);
                uint8_t *out_ptr_13 = output_ptr + 12 * sizeof(float);
                uint8_t *out_ptr_14 = output_ptr + 13 * sizeof(float);
                uint8_t *out_ptr_15 = output_ptr + 14 * sizeof(float);
                uint8_t *out_ptr_16 = output_ptr + 15 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = ADD_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = ADD_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = ADD_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = ADD_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                    *((float*)out_ptr_5) = ADD_F32(*((float*)in_ptr_1_5), *((float*)in_ptr_2_5));
                    in_ptr_1_5 += in_stride_1;
                    in_ptr_2_5 += in_stride_2;
                    out_ptr_5 += out_stride;
                    *((float*)out_ptr_6) = ADD_F32(*((float*)in_ptr_1_6), *((float*)in_ptr_2_6));
                    in_ptr_1_6 += in_stride_1;
                    in_ptr_2_6 += in_stride_2;
                    out_ptr_6 += out_stride;
                    *((float*)out_ptr_7) = ADD_F32(*((float*)in_ptr_1_7), *((float*)in_ptr_2_7));
                    in_ptr_1_7 += in_stride_1;
                    in_ptr_2_7 += in_stride_2;
                    out_ptr_7 += out_stride;
                    *((float*)out_ptr_8) = ADD_F32(*((float*)in_ptr_1_8), *((float*)in_ptr_2_8));
                    in_ptr_1_8 += in_stride_1;
                    in_ptr_2_8 += in_stride_2;
                    out_ptr_8 += out_stride;
                    *((float*)out_ptr_9) = ADD_F32(*((float*)in_ptr_1_9), *((float*)in_ptr_2_9));
                    in_ptr_1_9 += in_stride_1;
                    in_ptr_2_9 += in_stride_2;
                    out_ptr_9 += out_stride;
                    *((float*)out_ptr_10) = ADD_F32(*((float*)in_ptr_1_10), *((float*)in_ptr_2_10));
                    in_ptr_1_10 += in_stride_1;
                    in_ptr_2_10 += in_stride_2;
                    out_ptr_10 += out_stride;
                    *((float*)out_ptr_11) = ADD_F32(*((float*)in_ptr_1_11), *((float*)in_ptr_2_11));
                    in_ptr_1_11 += in_stride_1;
                    in_ptr_2_11 += in_stride_2;
                    out_ptr_11 += out_stride;
                    *((float*)out_ptr_12) = ADD_F32(*((float*)in_ptr_1_12), *((float*)in_ptr_2_12));
                    in_ptr_1_12 += in_stride_1;
                    in_ptr_2_12 += in_stride_2;
                    out_ptr_12 += out_stride;
                    *((float*)out_ptr_13) = ADD_F32(*((float*)in_ptr_1_13), *((float*)in_ptr_2_13));
                    in_ptr_1_13 += in_stride_1;
                    in_ptr_2_13 += in_stride_2;
                    out_ptr_13 += out_stride;
                    *((float*)out_ptr_14) = ADD_F32(*((float*)in_ptr_1_14), *((float*)in_ptr_2_14));
                    in_ptr_1_14 += in_stride_1;
                    in_ptr_2_14 += in_stride_2;
                    out_ptr_14 += out_stride;
                    *((float*)out_ptr_15) = ADD_F32(*((float*)in_ptr_1_15), *((float*)in_ptr_2_15));
                    in_ptr_1_15 += in_stride_1;
                    in_ptr_2_15 += in_stride_2;
                    out_ptr_15 += out_stride;
                    *((float*)out_ptr_16) = ADD_F32(*((float*)in_ptr_1_16), *((float*)in_ptr_2_16));
                    in_ptr_1_16 += in_stride_1;
                    in_ptr_2_16 += in_stride_2;
                    out_ptr_16 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.add.\nsupported signatures are:\n  mathv.add(x:f32, y:f32)\n");
}

int am_mathv_sub(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.sub");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.sub.\nsupported signatures are:\n  mathv.sub(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.sub");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.sub argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to sub argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = SUB_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = SUB_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = SUB_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = SUB_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = SUB_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = SUB_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            case 9: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_5;
                if (arg_components[0] > 1) {
                    in_ptr_1_5 = &arg_data[0][0] + 4 * sizeof(float);
                } else {
                    in_ptr_1_5 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_6;
                if (arg_components[0] > 1) {
                    in_ptr_1_6 = &arg_data[0][0] + 5 * sizeof(float);
                } else {
                    in_ptr_1_6 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_7;
                if (arg_components[0] > 1) {
                    in_ptr_1_7 = &arg_data[0][0] + 6 * sizeof(float);
                } else {
                    in_ptr_1_7 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_8;
                if (arg_components[0] > 1) {
                    in_ptr_1_8 = &arg_data[0][0] + 7 * sizeof(float);
                } else {
                    in_ptr_1_8 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_9;
                if (arg_components[0] > 1) {
                    in_ptr_1_9 = &arg_data[0][0] + 8 * sizeof(float);
                } else {
                    in_ptr_1_9 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_5;
                if (arg_components[1] > 1) {
                    in_ptr_2_5 = &arg_data[1][0] + 4 * sizeof(float);
                } else {
                    in_ptr_2_5 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_6;
                if (arg_components[1] > 1) {
                    in_ptr_2_6 = &arg_data[1][0] + 5 * sizeof(float);
                } else {
                    in_ptr_2_6 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_7;
                if (arg_components[1] > 1) {
                    in_ptr_2_7 = &arg_data[1][0] + 6 * sizeof(float);
                } else {
                    in_ptr_2_7 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_8;
                if (arg_components[1] > 1) {
                    in_ptr_2_8 = &arg_data[1][0] + 7 * sizeof(float);
                } else {
                    in_ptr_2_8 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_9;
                if (arg_components[1] > 1) {
                    in_ptr_2_9 = &arg_data[1][0] + 8 * sizeof(float);
                } else {
                    in_ptr_2_9 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                uint8_t *out_ptr_5 = output_ptr + 4 * sizeof(float);
                uint8_t *out_ptr_6 = output_ptr + 5 * sizeof(float);
                uint8_t *out_ptr_7 = output_ptr + 6 * sizeof(float);
                uint8_t *out_ptr_8 = output_ptr + 7 * sizeof(float);
                uint8_t *out_ptr_9 = output_ptr + 8 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = SUB_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = SUB_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = SUB_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                    *((float*)out_ptr_5) = SUB_F32(*((float*)in_ptr_1_5), *((float*)in_ptr_2_5));
                    in_ptr_1_5 += in_stride_1;
                    in_ptr_2_5 += in_stride_2;
                    out_ptr_5 += out_stride;
                    *((float*)out_ptr_6) = SUB_F32(*((float*)in_ptr_1_6), *((float*)in_ptr_2_6));
                    in_ptr_1_6 += in_stride_1;
                    in_ptr_2_6 += in_stride_2;
                    out_ptr_6 += out_stride;
                    *((float*)out_ptr_7) = SUB_F32(*((float*)in_ptr_1_7), *((float*)in_ptr_2_7));
                    in_ptr_1_7 += in_stride_1;
                    in_ptr_2_7 += in_stride_2;
                    out_ptr_7 += out_stride;
                    *((float*)out_ptr_8) = SUB_F32(*((float*)in_ptr_1_8), *((float*)in_ptr_2_8));
                    in_ptr_1_8 += in_stride_1;
                    in_ptr_2_8 += in_stride_2;
                    out_ptr_8 += out_stride;
                    *((float*)out_ptr_9) = SUB_F32(*((float*)in_ptr_1_9), *((float*)in_ptr_2_9));
                    in_ptr_1_9 += in_stride_1;
                    in_ptr_2_9 += in_stride_2;
                    out_ptr_9 += out_stride;
                }
                return 1;
            }
            case 16: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_5;
                if (arg_components[0] > 1) {
                    in_ptr_1_5 = &arg_data[0][0] + 4 * sizeof(float);
                } else {
                    in_ptr_1_5 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_6;
                if (arg_components[0] > 1) {
                    in_ptr_1_6 = &arg_data[0][0] + 5 * sizeof(float);
                } else {
                    in_ptr_1_6 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_7;
                if (arg_components[0] > 1) {
                    in_ptr_1_7 = &arg_data[0][0] + 6 * sizeof(float);
                } else {
                    in_ptr_1_7 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_8;
                if (arg_components[0] > 1) {
                    in_ptr_1_8 = &arg_data[0][0] + 7 * sizeof(float);
                } else {
                    in_ptr_1_8 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_9;
                if (arg_components[0] > 1) {
                    in_ptr_1_9 = &arg_data[0][0] + 8 * sizeof(float);
                } else {
                    in_ptr_1_9 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_10;
                if (arg_components[0] > 1) {
                    in_ptr_1_10 = &arg_data[0][0] + 9 * sizeof(float);
                } else {
                    in_ptr_1_10 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_11;
                if (arg_components[0] > 1) {
                    in_ptr_1_11 = &arg_data[0][0] + 10 * sizeof(float);
                } else {
                    in_ptr_1_11 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_12;
                if (arg_components[0] > 1) {
                    in_ptr_1_12 = &arg_data[0][0] + 11 * sizeof(float);
                } else {
                    in_ptr_1_12 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_13;
                if (arg_components[0] > 1) {
                    in_ptr_1_13 = &arg_data[0][0] + 12 * sizeof(float);
                } else {
                    in_ptr_1_13 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_14;
                if (arg_components[0] > 1) {
                    in_ptr_1_14 = &arg_data[0][0] + 13 * sizeof(float);
                } else {
                    in_ptr_1_14 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_15;
                if (arg_components[0] > 1) {
                    in_ptr_1_15 = &arg_data[0][0] + 14 * sizeof(float);
                } else {
                    in_ptr_1_15 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_16;
                if (arg_components[0] > 1) {
                    in_ptr_1_16 = &arg_data[0][0] + 15 * sizeof(float);
                } else {
                    in_ptr_1_16 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_5;
                if (arg_components[1] > 1) {
                    in_ptr_2_5 = &arg_data[1][0] + 4 * sizeof(float);
                } else {
                    in_ptr_2_5 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_6;
                if (arg_components[1] > 1) {
                    in_ptr_2_6 = &arg_data[1][0] + 5 * sizeof(float);
                } else {
                    in_ptr_2_6 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_7;
                if (arg_components[1] > 1) {
                    in_ptr_2_7 = &arg_data[1][0] + 6 * sizeof(float);
                } else {
                    in_ptr_2_7 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_8;
                if (arg_components[1] > 1) {
                    in_ptr_2_8 = &arg_data[1][0] + 7 * sizeof(float);
                } else {
                    in_ptr_2_8 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_9;
                if (arg_components[1] > 1) {
                    in_ptr_2_9 = &arg_data[1][0] + 8 * sizeof(float);
                } else {
                    in_ptr_2_9 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_10;
                if (arg_components[1] > 1) {
                    in_ptr_2_10 = &arg_data[1][0] + 9 * sizeof(float);
                } else {
                    in_ptr_2_10 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_11;
                if (arg_components[1] > 1) {
                    in_ptr_2_11 = &arg_data[1][0] + 10 * sizeof(float);
                } else {
                    in_ptr_2_11 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_12;
                if (arg_components[1] > 1) {
                    in_ptr_2_12 = &arg_data[1][0] + 11 * sizeof(float);
                } else {
                    in_ptr_2_12 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_13;
                if (arg_components[1] > 1) {
                    in_ptr_2_13 = &arg_data[1][0] + 12 * sizeof(float);
                } else {
                    in_ptr_2_13 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_14;
                if (arg_components[1] > 1) {
                    in_ptr_2_14 = &arg_data[1][0] + 13 * sizeof(float);
                } else {
                    in_ptr_2_14 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_15;
                if (arg_components[1] > 1) {
                    in_ptr_2_15 = &arg_data[1][0] + 14 * sizeof(float);
                } else {
                    in_ptr_2_15 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_16;
                if (arg_components[1] > 1) {
                    in_ptr_2_16 = &arg_data[1][0] + 15 * sizeof(float);
                } else {
                    in_ptr_2_16 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                uint8_t *out_ptr_5 = output_ptr + 4 * sizeof(float);
                uint8_t *out_ptr_6 = output_ptr + 5 * sizeof(float);
                uint8_t *out_ptr_7 = output_ptr + 6 * sizeof(float);
                uint8_t *out_ptr_8 = output_ptr + 7 * sizeof(float);
                uint8_t *out_ptr_9 = output_ptr + 8 * sizeof(float);
                uint8_t *out_ptr_10 = output_ptr + 9 * sizeof(float);
                uint8_t *out_ptr_11 = output_ptr + 10 * sizeof(float);
                uint8_t *out_ptr_12 = output_ptr + 11 * sizeof(float);
                uint8_t *out_ptr_13 = output_ptr + 12 * sizeof(float);
                uint8_t *out_ptr_14 = output_ptr + 13 * sizeof(float);
                uint8_t *out_ptr_15 = output_ptr + 14 * sizeof(float);
                uint8_t *out_ptr_16 = output_ptr + 15 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = SUB_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = SUB_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = SUB_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = SUB_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                    *((float*)out_ptr_5) = SUB_F32(*((float*)in_ptr_1_5), *((float*)in_ptr_2_5));
                    in_ptr_1_5 += in_stride_1;
                    in_ptr_2_5 += in_stride_2;
                    out_ptr_5 += out_stride;
                    *((float*)out_ptr_6) = SUB_F32(*((float*)in_ptr_1_6), *((float*)in_ptr_2_6));
                    in_ptr_1_6 += in_stride_1;
                    in_ptr_2_6 += in_stride_2;
                    out_ptr_6 += out_stride;
                    *((float*)out_ptr_7) = SUB_F32(*((float*)in_ptr_1_7), *((float*)in_ptr_2_7));
                    in_ptr_1_7 += in_stride_1;
                    in_ptr_2_7 += in_stride_2;
                    out_ptr_7 += out_stride;
                    *((float*)out_ptr_8) = SUB_F32(*((float*)in_ptr_1_8), *((float*)in_ptr_2_8));
                    in_ptr_1_8 += in_stride_1;
                    in_ptr_2_8 += in_stride_2;
                    out_ptr_8 += out_stride;
                    *((float*)out_ptr_9) = SUB_F32(*((float*)in_ptr_1_9), *((float*)in_ptr_2_9));
                    in_ptr_1_9 += in_stride_1;
                    in_ptr_2_9 += in_stride_2;
                    out_ptr_9 += out_stride;
                    *((float*)out_ptr_10) = SUB_F32(*((float*)in_ptr_1_10), *((float*)in_ptr_2_10));
                    in_ptr_1_10 += in_stride_1;
                    in_ptr_2_10 += in_stride_2;
                    out_ptr_10 += out_stride;
                    *((float*)out_ptr_11) = SUB_F32(*((float*)in_ptr_1_11), *((float*)in_ptr_2_11));
                    in_ptr_1_11 += in_stride_1;
                    in_ptr_2_11 += in_stride_2;
                    out_ptr_11 += out_stride;
                    *((float*)out_ptr_12) = SUB_F32(*((float*)in_ptr_1_12), *((float*)in_ptr_2_12));
                    in_ptr_1_12 += in_stride_1;
                    in_ptr_2_12 += in_stride_2;
                    out_ptr_12 += out_stride;
                    *((float*)out_ptr_13) = SUB_F32(*((float*)in_ptr_1_13), *((float*)in_ptr_2_13));
                    in_ptr_1_13 += in_stride_1;
                    in_ptr_2_13 += in_stride_2;
                    out_ptr_13 += out_stride;
                    *((float*)out_ptr_14) = SUB_F32(*((float*)in_ptr_1_14), *((float*)in_ptr_2_14));
                    in_ptr_1_14 += in_stride_1;
                    in_ptr_2_14 += in_stride_2;
                    out_ptr_14 += out_stride;
                    *((float*)out_ptr_15) = SUB_F32(*((float*)in_ptr_1_15), *((float*)in_ptr_2_15));
                    in_ptr_1_15 += in_stride_1;
                    in_ptr_2_15 += in_stride_2;
                    out_ptr_15 += out_stride;
                    *((float*)out_ptr_16) = SUB_F32(*((float*)in_ptr_1_16), *((float*)in_ptr_2_16));
                    in_ptr_1_16 += in_stride_1;
                    in_ptr_2_16 += in_stride_2;
                    out_ptr_16 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.sub.\nsupported signatures are:\n  mathv.sub(x:f32, y:f32)\n");
}

int am_mathv_mul(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.mul");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.mul.\nsupported signatures are:\n  mathv.mul(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.mul");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.mul argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to mul argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = MUL_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = MUL_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = MUL_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = MUL_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = MUL_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = MUL_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = MUL_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = MUL_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = MUL_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = MUL_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.mul.\nsupported signatures are:\n  mathv.mul(x:f32, y:f32)\n");
}

int am_mathv_div(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.div");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.div.\nsupported signatures are:\n  mathv.div(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.div");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.div argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to div argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = DIV_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = DIV_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = DIV_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = DIV_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = DIV_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = DIV_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = DIV_F32(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = DIV_F32(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = DIV_F32(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = DIV_F32(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.div.\nsupported signatures are:\n  mathv.div(x:f32, y:f32)\n");
}

int am_mathv_mod(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.mod");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.mod.\nsupported signatures are:\n  mathv.mod(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.mod");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.mod argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to mod argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = fmodf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = fmodf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = fmodf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = fmodf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = fmodf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = fmodf(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = fmodf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = fmodf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = fmodf(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = fmodf(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.mod.\nsupported signatures are:\n  mathv.mod(x:f32, y:f32)\n");
}

int am_mathv_pow(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.pow");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.pow.\nsupported signatures are:\n  mathv.pow(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.pow");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.pow argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to pow argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
                if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = powf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = powf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = powf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = powf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = powf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = powf(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                int in_stride_2 = arg_stride[1];
                uint8_t *in_ptr_2_1;
                if (arg_components[1] > 1) {
                    in_ptr_2_1 = &arg_data[1][0] + 0 * sizeof(float);
                } else {
                    in_ptr_2_1 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_2;
                if (arg_components[1] > 1) {
                    in_ptr_2_2 = &arg_data[1][0] + 1 * sizeof(float);
                } else {
                    in_ptr_2_2 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_3;
                if (arg_components[1] > 1) {
                    in_ptr_2_3 = &arg_data[1][0] + 2 * sizeof(float);
                } else {
                    in_ptr_2_3 = &arg_data[1][0];
                }
                uint8_t *in_ptr_2_4;
                if (arg_components[1] > 1) {
                    in_ptr_2_4 = &arg_data[1][0] + 3 * sizeof(float);
                } else {
                    in_ptr_2_4 = &arg_data[1][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = powf(*((float*)in_ptr_1_1), *((float*)in_ptr_2_1));
                    in_ptr_1_1 += in_stride_1;
                    in_ptr_2_1 += in_stride_2;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = powf(*((float*)in_ptr_1_2), *((float*)in_ptr_2_2));
                    in_ptr_1_2 += in_stride_1;
                    in_ptr_2_2 += in_stride_2;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = powf(*((float*)in_ptr_1_3), *((float*)in_ptr_2_3));
                    in_ptr_1_3 += in_stride_1;
                    in_ptr_2_3 += in_stride_2;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = powf(*((float*)in_ptr_1_4), *((float*)in_ptr_2_4));
                    in_ptr_1_4 += in_stride_1;
                    in_ptr_2_4 += in_stride_2;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.pow.\nsupported signatures are:\n  mathv.pow(x:f32, y:f32)\n");
}

int am_mathv_unm(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.unm");
    double arg_singleton_vals[1][16];
    int arg_count[1];
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.unm.\nsupported signatures are:\n  mathv.unm(x:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.unm");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.unm argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to unm argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = UNM_F32(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = UNM_F32(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = UNM_F32(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = UNM_F32(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = UNM_F32(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = UNM_F32(*((float*)in_ptr_1_3));
                    in_ptr_1_3 += in_stride_1;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = UNM_F32(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = UNM_F32(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = UNM_F32(*((float*)in_ptr_1_3));
                    in_ptr_1_3 += in_stride_1;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = UNM_F32(*((float*)in_ptr_1_4));
                    in_ptr_1_4 += in_stride_1;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.unm.\nsupported signatures are:\n  mathv.unm(x:f32)\n");
}

int am_mathv_sin(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.sin");
    double arg_singleton_vals[1][16];
    int arg_count[1];
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.sin.\nsupported signatures are:\n  mathv.sin(angle:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.sin");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.sin argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to sin argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = sinf(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.sin.\nsupported signatures are:\n  mathv.sin(angle:f32)\n");
}

int am_mathv_dot(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.dot");
    double arg_singleton_vals[2][16];
    int arg_count[2];
    uint8_t *arg_data[2];
    int arg_stride[2];
    int arg_components[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.dot.\nsupported signatures are:\n  mathv.dot(x:f32, y:f32)\n  mathv.dot(x:f32, y:f32)\n  mathv.dot(x:f32, y:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.dot");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.dot argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = sizeof(float) * 1;
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * out_stride);
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, 1);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = sizeof(float) * 1;
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * out_stride);
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, 1);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[0] = (uint8_t*)f64s;
        }
        if (arg_type[1] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[1][0];
            float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[1]; i++) {
                conv[i] = (float)f64s[i];
            }
            arg_data[1] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = sizeof(float) * 1;
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * out_stride);
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, 1);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (int i = 0; i < count; ++i) {
            *((float*)output_ptr) = glm::dot(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_ptr += out_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.dot.\nsupported signatures are:\n  mathv.dot(x:f32, y:f32)\n  mathv.dot(x:f32, y:f32)\n  mathv.dot(x:f32, y:f32)\n");
}

void am_open_mathv_module(lua_State *L) {
    luaL_Reg vfuncs[] = {
        {"range", am_mathv_range},
        {"random", am_mathv_random},
        {"cart", am_mathv_cart},
    {"add", am_mathv_add},
    {"sub", am_mathv_sub},
    {"mul", am_mathv_mul},
    {"div", am_mathv_div},
    {"mod", am_mathv_mod},
    {"pow", am_mathv_pow},
    {"unm", am_mathv_unm},
    {"sin", am_mathv_sin},
    {"dot", am_mathv_dot},
        {NULL, NULL}
    };
    am_open_module(L, "mathv", vfuncs);
}
