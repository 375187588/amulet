// This file is generated by tools/gen_mathv.lua
#include "amulet.h"
#include "am_mathv_helper.inc"
int mathv_sin(lua_State *L) {
    int nargs = lua_gettop(L);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.sin");
    double arg_singleton_vals[1][16];
    int arg_count[1];
    uint8_t *arg_data[1];
    int arg_stride[1];
    int arg_components[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    for (int i = 0; i < nargs; i++) {
        if (!read_arg(L, i+1, &arg_type[i], &arg_view_type[i], &arg_data[i], &arg_stride[i], &arg_count[i], &arg_components[i], &arg_singleton_vals[i][0])) {
            return luaL_error(L, "invalid argument types for function mathv.sin.\nsupported signatures are:\n  mathv.sin(angle:f32)\n");
        }
    }
    // code below depends on there being at least one arg
    if (nargs == 0) return luaL_error(L, "no arguments given for mathv.sin");
    // compute count
    int count = -1;
    for (int i = 0; i < nargs; i++) {
        if (arg_type[i] == MT_am_buffer_view) {
            if (count != -1 && arg_count[i] != count) {
                return luaL_error(L, "in call to mathv.sin argument %d has size %d, but previous arguments have size %d", (i+1), arg_count[i], count);
            } else if (count == -1) {
                count = arg_count[i];
            }
        }
    }
    bool no_view_args = false;
    if (count == -1) {
        no_view_args = true;
        count = 1;
    }
    int output_components = arg_components[0];
    for (int i = 1; i < nargs; i++) {
        if (output_components != arg_components[i]) {
            if (output_components == 1) {
                output_components = arg_components[i];
            } else if (arg_components[i] != 1) {
                return luaL_error(L, "in call to sin argument %d has %d components, but previous arguments have %d components",
                    i+1, arg_components[i], output_components);
            }
        }
    }
    if (nargs == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        // setup non-view args
        if (arg_type[0] != MT_am_buffer_view) {
            double *f64s = &arg_singleton_vals[0][0];
                    float *conv = (float*)f64s;
            for (int i = 0; i < arg_components[0]; i++) {
                conv[i] = (float)f64s[i];
            }
                        arg_data[0] = (uint8_t*)f64s;
        }
        uint8_t *output_ptr;
        int out_stride = output_components * sizeof(float);
        
        am_buffer *output_buffer = am_push_new_buffer_and_init(L, count * output_components * sizeof(float));
        output_ptr = output_buffer->data;
        am_buffer_view *output_view = am_new_buffer_view(L, AM_VIEW_TYPE_F32, output_components);
        output_view->buffer = output_buffer;
        output_view->buffer_ref = output_view->ref(L, -2);
        output_view->offset = 0;
        output_view->stride = out_stride;
        output_view->size = count;
        output_view->last_max_elem_version = 0;
        output_view->max_elem = 0;
        
        lua_remove(L, -2); // remove output_buffer
        switch(output_components) {
            case 1: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = sinf(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                }
                return 1;
            }
            case 2: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = sinf(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = sinf(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                }
                return 1;
            }
            case 3: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = sinf(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = sinf(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = sinf(*((float*)in_ptr_1_3));
                    in_ptr_1_3 += in_stride_1;
                    out_ptr_3 += out_stride;
                }
                return 1;
            }
            case 4: {
                int in_stride_1 = arg_stride[0];
                uint8_t *in_ptr_1_1;
                if (arg_components[0] > 1) {
                    in_ptr_1_1 = &arg_data[0][0] + 0 * sizeof(float);
                } else {
                    in_ptr_1_1 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_2;
                if (arg_components[0] > 1) {
                    in_ptr_1_2 = &arg_data[0][0] + 1 * sizeof(float);
                } else {
                    in_ptr_1_2 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_3;
                if (arg_components[0] > 1) {
                    in_ptr_1_3 = &arg_data[0][0] + 2 * sizeof(float);
                } else {
                    in_ptr_1_3 = &arg_data[0][0];
                }
                uint8_t *in_ptr_1_4;
                if (arg_components[0] > 1) {
                    in_ptr_1_4 = &arg_data[0][0] + 3 * sizeof(float);
                } else {
                    in_ptr_1_4 = &arg_data[0][0];
                }
                uint8_t *out_ptr_1 = output_ptr + 0 * sizeof(float);
                uint8_t *out_ptr_2 = output_ptr + 1 * sizeof(float);
                uint8_t *out_ptr_3 = output_ptr + 2 * sizeof(float);
                uint8_t *out_ptr_4 = output_ptr + 3 * sizeof(float);
                for (int i = 0; i < count; ++i) {
                    *((float*)out_ptr_1) = sinf(*((float*)in_ptr_1_1));
                    in_ptr_1_1 += in_stride_1;
                    out_ptr_1 += out_stride;
                    *((float*)out_ptr_2) = sinf(*((float*)in_ptr_1_2));
                    in_ptr_1_2 += in_stride_1;
                    out_ptr_2 += out_stride;
                    *((float*)out_ptr_3) = sinf(*((float*)in_ptr_1_3));
                    in_ptr_1_3 += in_stride_1;
                    out_ptr_3 += out_stride;
                    *((float*)out_ptr_4) = sinf(*((float*)in_ptr_1_4));
                    in_ptr_1_4 += in_stride_1;
                    out_ptr_4 += out_stride;
                }
                return 1;
            }
            default:
                return luaL_error(L, "internal error: unexpected number of output components: %d", output_components);
        }
    }
    return luaL_error(L, "invalid argument types for function mathv.sin.\nsupported signatures are:\n  mathv.sin(angle:f32)\n");
}

