- Detect and handle cyclic module imports

- Add context to errors that occur in rendering (e.g. missing uniform
  values). This would require the lua file/line to be recorded when nodes
  are created. Assess the performance tradeoff of doing this.

- Show user-code context in main error message, not embedded-lua context.
  (can still show embedded-lua in stack trace)

- Make transform nodes (tranlate, rotate, scale, lookat, billboard, etc)
  operated on MV and/or P by default.

- Allow omiting vec3 constructor in translate and scale, and quat constructor
  in rotate nodes (e.g. can write node:translate(0, 0) or similar).

- Add 2d versions of translate, rotate and scale that accept vec2s.

- Look at integrating luasocket for networking support (what about html
  backend?).

- Investigate whether double to int conversions in Lua 5.1/5.2 are
  slow. I might not be defining the right macros in my custom makefile
  to get the fast implementation of this, but then again maybe -ffast-math
  takes care of it?

- The convention of having module for different kinds of game objects
  isn't very convenient as we end up wanting to name instances of
  the object the same name as the module. What convention could
  we use to solve this. module return a constructor function perhaps?
  Need to try out some alternate conventions. (This is more a application
  code style thing, but thinking about it may lead to changes in amulet).

- Action execution order - still worried about this. How to
  easily ensure dependencies between actions are satisfied,
  so that we don't get e.g. some nodes being a frame behind.

- Lua5.1 and LuaJIT seem to do a full traversal of all objects to extract
  objects that need finalization. This happens as an atomic GC step
  (i.e. is not incremental).  See if this is a problem. It seems like it
  might cause pauses when there are many objects. Lua5.2 seems to not do this.
  Instead it puts finanizable objects on a separate list in setmetatable.  It
  does need to scan the full object list inside setmetatable to move the
  object, but usually the object should be near the front of the list, because
  we usually set the metatable soon after creating the object (check this).
  Update: this does seem to cause longer pauses with a large number of 
  objects for lua51 and luajit. lua52 seems ok, so default to using that,
  except with the html backend where lua52's coroutines are inefficient
  (because they use longjmp).

- Allow hot reloading of images / spritesheets (should be ok for spritesheets
  as long as sizes don't change).

- Allow hot reloading of code.  Establish convensions so this works most 
  of the time (impossible to work all the time).

- Implement console.

- Support y or z sorting.

- Change 'hidden' field on scene nodes to 'visible'.

- Use standard endianess for views. All target platforms use little endian,
  but big endian would be nice for 32 bit pixels. Then we could write colours
  as 0xAABBCCFF in RGBA order.

- Support other vec types in views, e.g. short2 (e.g. for UV coords) or ubyte4
  (e.g. for colours) or byte3 (e.g. for normals).
